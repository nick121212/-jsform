{"version":3,"sources":["../../src/libs/tree.ts"],"names":["isNumber","TreeMap","key","value","parent","children","keys","curNode","child","length","contains","toString","push","getIndexInParent","concat","getCurrentKeys","index","i","n","getKey","node","splice","toIndex","curIndex","removeFromParent","clearFunc","currentNode","forEach"],"mappings":"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","sourcesContent":["import { isNumber } from \"../utils\";\n\nexport type Tsn = string | number;\n\n/**\n * tree map struct\n * 这里用来记录数据的元数据信息\n * 元数据信息包括，isValid，isLoading，isShow，...etc\n */\nexport class TreeMap<T> {\n    public children: TreeMap<T>[] = [];\n\n    /**\n      * 构造函数\n      * @param   {String}  key    当前节点的key\n      * @param   {any}     value  当前节点的值\n      * @param   {TreeMap<T>} parent 当前节点的父亲节点\n      * @returns {Void}\n      */\n    constructor(private key: string, public value: any, public readonly parent?: TreeMap<T>) { }\n\n    /**\n    * 添加一个子元素\n    * @param    {Array<Tsn>} keys  节点的路径，遍历keys来动态创建节点 example [\"root\",\"b\"]  root -> b\n    * @param    {any}        value 孩子的数据\n    * @returns  {TreeMap<T>}\n    */\n    public addChild(keys: Array<Tsn>, value?: any): TreeMap<T> {\n        let curNode: TreeMap<T> = this;\n        let child: TreeMap<T> | null = null;\n\n        if (!keys.length) {\n            return this;\n        }\n\n        for (const key of keys) {\n            child = curNode.contains(key);\n\n            // 如果是数字的话，则说明是数组，key改成`-`\n            // 如果不是数组的话，则无所谓顺序，直接push就行\n            // 如果是数组，则要保证顺序和数据的下标一致\n            if (!child) {\n                if (isNumber(key)) {\n                    child = new TreeMap<T>(\"-\", null, curNode);\n                    curNode.children[key as number] = child;\n                } else {\n                    child = new TreeMap<T>(key.toString(), null, curNode);\n                    curNode.children.push(child);\n                }\n            }\n\n            curNode = child;\n        }\n\n        (child as TreeMap<T>).value = value;\n\n        return child as TreeMap<T>;\n    }\n\n    /**\n   * 获取当前的key\n   * 如果key是`-`,代表是数组，则转换成数组下标\n   * time complexity = O(1) / Constant\n   * @returns string\n   */\n    public getKey(): string {\n        if (!this.key || this.key === \"-\") {\n            return this.getIndexInParent().toString();\n        }\n\n        return this.key;\n    }\n\n    /**\n   * 获取当前节点的keys路径\n   * time complexity = O(1) / Constant\n   * @returns {string[]}\n   */\n    public getCurrentKeys(): Array<Tsn> {\n        let keys: Array<Tsn> = [];\n\n        if (this.parent) {\n            keys = keys.concat(this.parent.getCurrentKeys());\n        }\n\n        return keys.concat([this.key]);\n    }\n\n    /**\n    * 获取当前节点在父节点中的下标索引\n    * time complexity = O(1) / Constant\n    * @returns {number}\n    */\n    public getIndexInParent(): number {\n        let index = -1;\n\n        if (!this.parent) {\n            return index;\n        }\n\n        const { children } = this.parent;\n\n        for (let i = 0, n = children.length; i < n; i++) {\n            const child = children[i];\n\n            if (child && child === this) {\n                index = i;\n                break;\n            }\n        }\n\n        return index;\n    }\n\n    /**\n    * 从当前节点查找是否存在节点\n    * time complexity = O(n) / Linear\n    * @param   {Tsn}     key 节点的数据\n    * @returns {TreeMap<T>}\n    */\n    public contains(key: Tsn): TreeMap<T> | null {\n        // 如果是数字的话，直接返回children中对应下标的元素\n        if (isNumber(key)) {\n            if (this.children.length <= key) {\n                return null;\n            }\n\n            let child = this.children[key as number];\n\n            if (!child) {\n                this.children[key as number] = new TreeMap<T>(\"-\", null, this);\n\n                child = this.children[key as number];\n            }\n\n            return child;\n        }\n\n        // 如果当前节点的key===要搜索的key，则返回本身\n        if (this.getKey() === key) {\n            return this;\n        }\n\n        // 如果没有children，则返回空\n        if (!this.children || this.children.length === 0) {\n            return null;\n        }\n        // 遍历子节点，层层递归，直到找到\n        for (let i = 0; i < this.children.length; i++) {\n            const child = this.children[i];\n\n            if (child && child.contains(key)) {\n                return child;\n            }\n        }\n\n        return null;\n    }\n\n    /**\n    * 根据给定的路径数组，返回对应的节点\n    * time complexity = O(n) / Linear\n    * @param   {Array<Tsn>}    keys路径\n    * @returns {TreeMap<T> | null}\n    */\n    public containPath(keys: Array<Tsn>): TreeMap<T> | null {\n        let node: TreeMap<T> | null = this;\n\n        for (const key of keys) {\n            node = node.contains(key);\n\n            if (!node) {\n                break;\n            }\n        }\n\n        return node;\n    }\n\n    /**\n    * 从父亲节点中删除当前节点\n    * time complexity = O(n) / Linear\n    */\n    public removeFromParent(): void {\n        const index = this.getIndexInParent();\n\n        if (!this.parent) {\n            return;\n        }\n\n        this.parent.children.splice(index, 1);\n    }\n\n    /**\n    * 移动到某个位置\n    * time complexity = O(1) / Linear\n    * @param   {Number} toIndex 需要移动到的位置\n    * @returns {Void}\n    */\n    public insertToFromParent(toIndex: number): void {\n        let curIndex = this.getIndexInParent();\n\n        // 如果没有父亲，或者父亲没有子节点，或者当前位置小于0\n        if (!this.parent || !this.parent.children || curIndex < 0) {\n            return;\n        }\n\n        // 父亲节点中删除当前元素\n        this.removeFromParent();\n\n        // 如果超出了父亲的子节点数量，添加一个\n        if (this.parent.children.length <= toIndex) {\n            this.parent.children[toIndex] = this;\n            return;\n        }\n\n        // 将当前节点插入到指定的位置\n        this.parent.children.splice(toIndex, 0, this);\n    }\n\n    /**\n    * 遍历指定节点下所有子节点的value数据,当前节点不计算在内\n    * @param   {(node: TreeMap<T>) => any}     clearFunc      map方法\n    * @param   {Boolean}                    currentNode    是否包含当前节点\n    * @returns {Void}\n    */\n    public forEach(clearFunc: (node: TreeMap<T>) => any, currentNode = false) {\n        if (currentNode) {\n            this.value = clearFunc(this);\n        }\n\n        for (let i = 0, n = this.children.length; i < n; i++) {\n            let child = this.children[i];\n\n            if (child) {\n                child.value = clearFunc(child);\n                child.forEach(clearFunc);\n            }\n        }\n    }\n}\n"],"file":"tree.js"}