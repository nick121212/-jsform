{"version":3,"sources":["../../src/libs/resolve.ts"],"names":["invariant","schemaFieldFactory","schemaKeysFactory","schemaTypeFactory","isString","getDataKeysBySchemaPath","schemaPath","keepFirst","regexp","split","map","key","index","test","lastIndex","replace","filter","getKeysByKeyPath","keyPath","schemaId","getSchemaId","keys","length","initSchema","schema","$id","$ref","compileSchema","has","id","schemaGenera","get","type","toString","indexOf","resolve","getSchemaFromKeyPath","originKeyPath","keyPathExist","keyPathNotExist","join","push","pop","schemaExist","console","error","reverse","getSubSchemas","curScehma","Object","properties","k"],"mappings":"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","sourcesContent":["import { JSONSchema6 } from \"json-schema\";\nimport invariant from \"invariant\";\n\nimport {\n    schemaFieldFactory,\n    schemaKeysFactory,\n    schemaTypeFactory,\n} from \"../factory\";\nimport { isString } from \"../utils\";\nimport { UiSchema } from \"../models\";\n\n/**\n * schema路径解析\n * 把schemaPath解析成JsonPath\n * 1. 去掉properties，items关键字转换成【 - 】\n * 2. 第一个字符去掉末尾的【 # 】\n * @example design#/properties/appType => [\"appType']\n * @example design#/properties/appType/type => [\"appType','type']\n * @example design#/properties/appType/items/properties/type => [\"appType', '-', 'type']\n * @param   {String}    schemaPath schemaPath\n * @param   {Boolean}   keepFirst  是否需要保留schemaId\n * @returns {String[]}             返回数据路径数组\n */\nconst getDataKeysBySchemaPath = (\n    schemaPath: string,\n    keepFirst = false\n): string[] => {\n    const regexp = /#$/g;\n\n    return schemaPath\n        .split(\"/\")\n        .map((key: string, index: number) => {\n            // 第一个替换末尾的#\n            if (index === 0 && regexp.test(key)) {\n                // 这里是regexp的陷阱,需要修改lastIndex = 0\n                // 对于同一个正则表达式对象regex，不能重复调用：第一次返回true，第二次就返回false，很显然这种效果不是我们想要的。\n                // 这是因为RegExp.test()方法，第一次从位置0开始查找，可以匹配；第二次的查找位置就不是0了，说以就不能匹配了。\n                regexp.lastIndex = 0;\n\n                return keepFirst ? key.replace(regexp, \"\") : null;\n            }\n\n            // 去掉properties\n            if (key === \"properties\") {\n                return null;\n            }\n\n            // 转换items成-\n            if (key === \"items\") {\n                return \"-\";\n            }\n\n            return key;\n        })\n        .filter((key: string | null) => {\n            return key !== null;\n        }) as string[];\n};\n\n/**\n * 通过keypath获取数据路径\n *\n * @param {string} schemaPath\n * @param {string} keyPath\n * @returns\n */\nconst getKeysByKeyPath = (schemaPath: string, keyPath: string) => {\n    const schemaId = getSchemaId(schemaPath);\n\n    return keyPath\n        .split(\"/\")\n        .map((key: string, index: number) => {\n            if (index === 0 && key === schemaId) {\n                return null;\n            }\n\n            return key;\n        })\n        .filter((key: string | null) => {\n            return key !== null;\n        }) as string[];\n};\n\n/**\n * 从schemaPath中获取$id\n * @param   {String} schemaPath schemaPath\n * @returns {String}\n */\nconst getSchemaId = (schemaPath: string): string => {\n    const keys = schemaPath.split(\"/\");\n    const regexp = /#$/g;\n\n    if (!keys.length) {\n        // invariant(false, `${schemaPath} not a valid schemaPath.`);\n        return \"\";\n    }\n\n    return keys[0].replace(regexp, \"\");\n};\n\n/**\n * 初始化schema\n * 1. 判断$id，如果不存在，报错\n * 2. 验证schema的结构是否正确，不正确报错\n * @param   {JSONSchema6}  schema  schema\n * @returns {JSONSchema6}          处理完成的schema\n */\nconst initSchema = (schema: JSONSchema6): JSONSchema6 => {\n    let $id: string | undefined = schema.$id;\n\n    // 如果没有$id, 同时没有$ref的情况下直接报错\n    if (!$id && !schema.$ref) {\n        invariant(false, \"id is required\");\n        return schema;\n    }\n\n    return schema;\n};\n\n/**\n * TODO\n * 遍历schema，生成map\n * 1. 如果schema.type不是string，报错\n * 2. 调用【schemaTypeFactory\n * @param {JSONSchema6} schema  schema\n * @param {String}      $id     id\n */\nconst compileSchema = ($id: string, schema: JSONSchema6): JSONSchema6 => {\n    if (!schemaTypeFactory.has(\"normal\")) {\n        return schema;\n    }\n\n    const id = $id || (schema.$id || \"\") + \"#\";\n    let schemaGenera = schemaTypeFactory.get(\"normal\")(id, schema);\n\n    // 如果不存在type，但是$ref则直接返回\n    if (!schema.type || schema.$ref) {\n        return schemaGenera;\n    }\n\n    // 这里只解析type为字符串的结构，不支持数组类型的type\n    if (!isString(schema.type)) {\n        invariant(false, `schema type[${schema.type}] can only be string.`);\n        return schemaGenera;\n    }\n\n    const type: string = schema.type.toString();\n\n    // 这里调用相对应的type的方法，来解析schema\n    if (schemaTypeFactory.has(type) && [\"array\", \"object\"].indexOf(type) >= 0) {\n        schemaGenera = schemaTypeFactory.get(type)(id, schema);\n    }\n\n    return schemaGenera;\n};\n\n/**\n * 解析schema\n * @param  {JSONSchema6}   schema      需要处理的JsonSchema\n * @param  {String}        $id         JsonSchema 的id\n * @returns {JSONSchema6}              返回处理过后的JsonSchema\n */\nconst resolve = (schema: JSONSchema6, $id = \"\"): JSONSchema6 => {\n    const schemaGenera = !$id ? initSchema(schema) : schema;\n    const id = $id || schema.$ref || \"\";\n\n    // 生成map\n    return compileSchema(id, schemaGenera);\n};\n\n/**\n * 通过数据路径找到当前的schema\n *\n * @param {string} keyPath       数据路径\n * @returns {JsFormJsonSchema}   Schema\n */\nconst getSchemaFromKeyPath = (\n    keyPath: string,\n    originKeyPath?: string\n): UiSchema => {\n    let keyPathExist = keyPath.split(\"/\");\n    let keyPathNotExist = [];\n\n    while (keyPathExist.length) {\n        if (!schemaKeysFactory.has(keyPathExist.join(\"/\"))) {\n            keyPathNotExist.push(keyPathExist.pop());\n        } else {\n            break;\n        }\n    }\n\n    // 路径存在，直接返回schema\n    if (!keyPathNotExist.length) {\n        const schema = schemaFieldFactory.get(schemaKeysFactory.get(keyPath));\n\n        return {\n            ...schema,\n            keys: getKeysByKeyPath(\n                schema.schemaPath ?? \"\",\n                originKeyPath || keyPath\n            ),\n            key: originKeyPath || keyPath,\n        };\n    }\n\n    const schemaExist = schemaFieldFactory.get(\n        schemaKeysFactory.get(keyPathExist.join(\"/\"))\n    );\n\n    // 如果没有找到，并且存在$ref，则使用$ref再次查找，不然则抛出异常\n    if (!schemaExist?.$ref) {\n        console.error(`there is no schema in [${keyPath}]`);\n        throw invariant(false, `there is no schema in [${keyPath}]`);\n    }\n\n    // 继续查找 使用$ref + keyPathNotExist部分作为keyPath\n    return getSchemaFromKeyPath(\n        getDataKeysBySchemaPath(\n            [schemaExist.$ref, ...keyPathNotExist.reverse()].join(\"/\"),\n            true\n        ).join(\"/\"),\n        originKeyPath || keyPath\n    );\n};\n\n\n/**\n * 获取当前路径之后的子schema\n * \n * @param {string} keyPath \n * @returns {UiSchema[]} \n */\nconst getSubSchemas = (keyPath: string): UiSchema[] => {\n    const curScehma = getSchemaFromKeyPath(keyPath);\n\n    if (curScehma.type === \"object\") {\n        return (\n            Object.keys(curScehma.properties ?? {}).map((k: string) => {\n                return getSchemaFromKeyPath(`${keyPath}/${k}`);\n            }) || []\n        );\n    }\n\n    if (curScehma.type === \"array\") {\n        return [getSchemaFromKeyPath(`${keyPath}/-`)];\n    }\n\n    return [];\n};\n\nexport {\n    getDataKeysBySchemaPath,\n    getSchemaId,\n    resolve,\n    getSchemaFromKeyPath,\n    getSubSchemas,\n};\n"],"file":"resolve.js"}